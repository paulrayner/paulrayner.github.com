@lauren: I’ve made good progress on thinking through things concerning the newsletter today. Reading https://www.getdrip.com/blog/tips-and-tactics/email-newsletters-20-mistakes-to-avoid/ helped. I’m working on a series of blog posts about my DDD Europe talk, so the newsletter can point to those. That way I’m getting the best of both worlds. I also like the

Here's the plan:

. Write and publish a blog post on my DDD Europe talk.
. Send out newsletter linked to my talk. Use nice images of quotes etc.

Feedback:
Was expecting more in depth on how to handle design in agile environment. I didn't really hear the fixes that were mentioned in the title. I did enjoy the speaker, very fluent and well prepared presentation.

One immediately feels Paul has a lot of experience and knowledge up on his sleeves. The only drawback is that he has to pick a few topics to make it fit in a one hour talk. Very comprehensive and clear message.




* A little bit more on the conflicts in Agile-DDD teams, there was a little bit but then the rest of it sounded like a "lite" intro to DDD
* may be spend more time on the solutions then on the problems
* Session should be less trivial
* Totally resonates with my own experience as architect and agile coach.
* Very good, great content. The only problem I had was the room, so no problem with the presentation per se.
* "A bit of a clickbaity/sensationalist title, because it wasn't ""Agile"" that cripples the design work. It's doing Agile wrong. But it did serve as a good reminder that we should pay attention to certain pitfalls and it gave me more ammo to do agile coaching.
* Paul is very good at presenting with a good mix of interactivity and straight up knowledge sharing.
* better slides and more examples
* The session was filled with great information and the presenter had enough charisma to transport the information easily. 10/10!
* Paul Rayner is always a 10!

https://www.infoq.com/news/2016/06/rayner-ddd-agile-coexist

Attribute images to Stijn.

* Kudos for Mathias, Shawn & Jeroen for organizing DDD Europe. Encourage people to attend the next one.

What species of agile are we talking about here?

Include

Mention bounded and centered communities...

They are serving the process rather than the process serving them.

In his talk[https://www.youtube.com/watch?v=Bl30X0MvT0I] at Domain Driven Design Europe 2016, Paul Rayner made the case for incorporating domain-driven design (DDD) into the agile software delivery process.  He views agile as a way of organizing work, not as prescribing how to do the work. He believes agile practitioners often don't pay enough attention to design, and promotes DDD concepts as a way of addressing these failings.  Going further, Rayner believes that combining agile with DDD can accelerate product delivery.

In Rayner's experience as a consultant, he has seen many teams doing agile who stress the importance of MVP (minimum viable product) to the detriment of design. He quoted Douglas Martin on the inevitability of design: "The alternative to good design is bad design, not no design at all." In trying to avoid waterfall's "big design up front" and do the minimal work needed, these teams end up with bad design. The Agile Manifesto actually says "Continuous attention to technical excellence and good design enhances agility". The purpose of agile is not speed and only speed, but agility. Agility can be achieved through good design. It is in fact the purpose of design according to another quote Rayner offered up from Venkat Subramaniam: "A good design is not the one that correctly predicts the future, it's one that makes adapting to the future affordable."

He pointed out that design is fundamentally iterative, and as such, can be incorporated easily into agile.  Design is a process of discovering what you don't know and expressing complex ideas simply. Since you never know all the facts up front, your design will necessarily change over time. Taking the time to do the discovery, and to express new knowledge in the delivered code will pay dividends in time saved later, as the code itself will be more agile. One method for doing this is the whirlpool process of model exploration, in which you iterate between challenging your existing model of the domain with a new scenario, proposing a new model, and writing the code to implement it.

Rayner also listed other ways agile teams he has worked with often fail from a DDD perspective. One is viewing continuous refactoring to a good design as good enough. This may clean up the code, but DDD emphasizes introducing new concepts. These new concepts are not emergent from the code, and therefore cannot be created solely through refactoring, but rather are concepts modeled from the business. Which adds business value, whereas refactoring, by definition, does not change the functionality of the software.

Having a defined "product owner" role in Scrum can easily cause others on the team to view that person as the sole conduit for all business needs/knowledge, noted Rayner. DDD advocates that everyone know the domain. This is where the complexity lies, not in the technical aspects of the problem. So in order to achieve a good design, thereby increasing agility and business value, everyone on the delivery team needs to know the domain.

--------
Talk Transcript:

Paul Rayner:	How Agile can Cripple Effective Design Work.

While there is so much that is good about the Agile movement and what it has brought to software development compared to the work that I did in the 90s, which was at times very heavy weight and very process heavy. The pendulum in a lot of ways has swung away from that heavy weight kind of waterfall document driven to a less burdensome process, which is very refreshing.

Yet I find I go in and I work with a lot of teams and I find that these teams are still in a situation where they feel like they are serving the process instead of the process is serving them, does anyone ever feel like that, right?

That is not what the process is about, the process is meant to serve us, it is not about serving the process. I am using the process in sort of a technical sense there.

What I am going to do is I am going to talk about these main areas here.

Firstly, the inevitability of design, and we will dig into that, some faulty assumptions that I think a lot of teams that are doing Agile have about design. The connection between agility and design work and what does design agility kind of look like? What does it mean to be adaptive in your design, and what are some techniques that can help with that?

When I chose the catchphrase for my consulting company, I chose 'Leading By Design' and I chose that deliberately because I wanted people to understand that I feel what is important is that design can actually make you a leader in what you are doing. If you really understand design well, not only the process of design in terms of software design and the details of that, but also design as a discovery process, as a way of getting rid of the ignorance you have when starting a project and that can be a really powerful thing.

Firstly, let us talk about the inevitability of design. There is a great quote from Douglas Martin, basically what he is saying is that whether you like it or not you are doing design in your project, and whether or not you say you have time for design, you are doing design.

A lot of teams say, "We do not have time for design, we just always got to get the next feature done."

What does this quote say? It says, "You are doing design work, you are just doing bad design work. You are not being intentional about it, you are not doing it in a sustainable way."

He went on to say that it is about making conscious decisions. It is about approaching the problem that you are trying to solve in a way that is intentional and saying 'I am trying to figure this out, to structure this software in such a way that it has a fitness for purpose, that I understand what the purpose of the software is and how to structure the software so that it meets some kind of human need.'

I love this quote, it is from a friend of mine, Venkat, some of you may have heard him speak and the idea is 'What do we mean by a good design'? There is a mistaken assumption that a good design is basically "I am going to do a whole bunch of analysis and then I am going to come up with this design that is as close to perfect as I can make it so that it does not need to change. That is a good design." What Venkat is saying in this quote is that this kind of 'Predictive approach' to design is fundamentally flawed and that good design is actually adaptive, it is a design that allows you to be flexible where you need to be flexible. The terminology that Eric uses in the book is supple design. Design that is malleable where it needs to be malleable.

With design we are not trying to predict the future, we are trying to be adaptive in the right ways.

A big part of that, and I will be talking more about this later, is that design is fundamentally iterative. Let us talk about some faulty assumptions that I have come across. I am not saying these necessarily apply to you or to everyone, but these are some of the ones that I have come across when I have worked with teams.

Assumption number one: The product owner is the conduit for understanding business needs.

The idea here is that for teams that are maybe doing Scrum is that there is a role called the Product Owner. What a lot of teams end up doing as a technical team, is they defer everything in terms of understanding the business to the product owner. Anyone experienced this type of situation?

Ten years ago when I was doing development before Scrum became popular, you just substitute the term 'business analyst' instead of product owner and it was the same problem. I worked with a team several years ago where they had a business analyst working with the team and the team, I came and trained them in domain-driven design and started coaching them, and this business analyst, she would not let the team talk to the domain experts, to the business people. She said, 'that is my job, you stay in the room, you write the code, and let me talk to the business.' It is kind of like the ferrymen that rides, that goes across the river to Hades and you have to pay him some kind of money and he will take you across the river to Hades and you can rescue a soul and bring them back. It is that kind of feel of I need to be able to... I can not have a collaborative relationship with the business.

I see this kind of anti-pattern happening a lot with teams, here is another assumption.

Assumption number two: Technical considerations rather than business capabilities drive design decisions.

This takes a lot of different forms, with some teams this is what Jeff Atwell calls the "Magpie Developer syndrome." In Australia we have this bird called the Magpie that collects shiny objects and puts them in its nest. I think there is something equivalent to that in Europe, and as developers, as technical people, I am guilty of this as well, sometimes we can be like that. What is the newest framework? What is the newest language? That is what I want to do

We need to write a new web server and, oh my goodness, there's Elixir and somebody has just written this thing called Phoenix, let us do that because I want to learn a functional language and I want to write it in Phoenix because that's the cool new thing or I would really like to learn MongoDB or I would really like to learn Cassandra, whatever it happens to be and have those kinds of things drive design decisions.

Assumption number three:

This one, I think, is a little bit more of a presupposition, or an underlying assumption, that technical leadership and good design are not as important as process excellence. Most of what you hear about in the Agile community is an emphasis on process excellence, how to get better at Scrum, how to have better user stories, how to manage your backlog better, how to groom your backlog, how to have a more efficient daily stand up. Those are the kinds of things you hear at Agile conferences. I would know, I am convening, I am a member of the organizing community for an Agile conference in Denver in April and it is very very hard to find talk on topics other than Process Excellence. I think I have the only talk on the roster that talks about design.

There is this assumption that technical leadership and good design work are not as important as process excellence and these make our job much harder if we care about design. What has tended to happen in a lot of the agile community is that they say, 'Well, we do not want to do big design up front, so let us not do any design up front.' We have said 'We need to incrementally build MVPs, minimum viable products' and I am a big fan of this idea of building minimum viable products, minimum marketable features but what that has tended to do was compromise our ability to have a cohesive product design. Fred Brooks who wrote The Mythical Man Month years and years ago, if you have not read that book, you need to read that book it is a classic in software development, just as relevant today as it was when it was first written.

He talks about one of the chief roles of a software designer is to have a cohesive design. A design that actually coheres, makes sense, that has a conceptual integrity. We want a product design that has a conceptual integrity, and I will be talking about this later, but from a user experience perspective we want it to have a perceptual integrity as well. When customers, when users interact with our software, they should perceive that it is a seamless experience.

How about this one? What does the manifesto say, customer collaboration over contract negotiation. Working software over comprehensive documentation. Somehow that got to 'Let us not write any documentation at all.' I wrote a long blog post a few years ago on what I think about documentation and then I have been very excited to see Cyrille who is going to be speaking later in the conference, talking about living documentation. I highly encourage you to catch up with him, he has got a book out on Leanpub about that and then this one, the manifesto talks about customer collaboration and yet I see a lot of teams take a very passive role and basically say 'well, we are going to delegate a lot of those decisions to the product owner'.

Douglas Martin goes on and says 'Well, we are all making design decisions all the time, we just don't realize we are doing it. We are making trade offs, we can be conscious or we can be unconscious about that.' Back in 2011, Mary Poppendieck who has been very active in the Lean Software Development movement, talked about the problem with having amateur designers. What she meant by that is that writing user stories is a design activity, is what she put in this article. Writing user stories is a design activity, documenting requirements is a design activity, because you are making decisions, particularly the way most user stories are written or requirements, you are making decisions about language. You are making decisions about the interactions, with the system. What she says is that should be the responsibility of the people in the team who are actually good at design and not necessarily the person who is just responsible for churning out user stories.

This is a very famous moment, this is at the olympics, this is the US Relay team failing. The four fastest runners in the world, but they failed. Why did they fail? You can probably see it at the front of the room. Someone at the front of the room, why did they fail their relay? They dropped it. It is right here. Look at the look on his face.

Software development is fundamentally, as Alex Coburn said, it is a cooperative game. It is a collaborative game and we succeed or fail together on a software development team. Every time we introduce some kind of handoff in terms of design, some kind of hand off where someone is writing the user stories and someone else is responsible for writing them and they are not collaborating closely with each other? You can have this kind of thing happen where you are producing sub-optimal results, even if each person is very good at what they do, you can end up with an overall suboptimal result.

Let us talk about design agility, what does that look like? What are some things that can help us with that and I want to mention four main things. I have been teaching domain driven design for five years now and coaching teams in Domain Driven Design, so I speak with a very heavy DDD accent when I talk about design. I have also had the privilege of working with a lot of really good user experience designers and I have also done a lot of work in the BDD community, as well, behavior driven development. I tend to bring a lot of that in as well.

I want to talk about four things: (1) knowing your core domain, which Eric talked about in the keynote to a certain extent. (2) Creating and enforcing software to boundaries, (3) the importance of ubiquitous language, and (4) actually having your process be about design, having design just be an integral part of what you do as an activity. Let us talk about that.

[15 mins in...]

I really think this is a faulty assumption. What is this? The Rosetta Stone, located in the British Museum. I have been to London several times and been able to see it, just, you are on the other side of the security glass but it is really cool. The Rosetta Stone basically allowed antiquiters to be able to decipher Egyptian hieroglyphics for the very first time. Up until the discovery of the Rosetta stone, nobody was able to read Egyptian hieroglyphics. No one could read what was written on the walls of the tombs in Egypt, because they had Greek and Demotic script, they were able to translate, because it is the same text in all three languages, they were able to translate and interpret Hieroglyphics and it opened up that whole field.

The Rosetta Stone has become a symbol of that notion of translation between different things, and what I often find now is that it is very tempting for someone on the team to become that team's Rosetta Stone. I mentioned this in the workshop over the past couple of days, I often found I would be in the role of lead developer or architect or something like that and I would have the business people come to me and they would say 'Here is what we are trying to do' and I said 'Can't you just talk to the developers about that?' And they say 'No, they are too busy coding and stuff like that, and we will just explain it to you and you can explain it to them'.

Then the developers would say 'Alright, well, we have implemented this now you go explain that to the business people' so I was being put into that role of translating, and the Product Owner often ends up in that role as well, but they should not be. The role of the Product Owner in the Scrum process is to help the team understand the business value of the features they are delivering. To really understand what is important about this software and to be the champion of the software, but not to tell the team how to write the software, that is their job to figure that out. They are not the gatekeeper to the experts in the business, they are not the conduit for understanding what the software needs to do. DDD emphasizes really strongly, along with User experience design and behavior driven development, the importance of a collaborative role between the people that you are writing the software for and the actual ... the nontechnical people and the technical people.

Do not be a Rosetta Stone on your team. Instead, build relationships and trust. Have people on the team work with people from the business and grow the ability to respect eachother and bring the different abilities between the business customers, the domain experts, the technical experts, get people on the team involved together on developing this thing.

Let us talk a little bit about core domain. Eric mentioned it briefly, the idea with Core Domain is thinking about what in this software actually contributes to the competitive advantage for your company, what is your secret sauce. That might seem a little abstract but I will dig into that in a little bit. The idea is if you can figure that out, if you can figure out what your business goals are for your software, then write as little custom software as possible to accomplish that, to deliver that. Every line of code you write, you have to maintain and it is going to be there for potentially a long time, and not just you maintain it, but other people down the road. There is some software that I wrote, I worked on a Mine planning, mine modeling system from 1990 through to 1995 for a company called Maptek.

This software ran on silicon graphic workstations, and it was, which were the highest end Linux workstations that you could get at the time. These were the same workstations that they would use to make special effects for movies like Jurassic Park. I had one at my desk, and we would use this software and what they could do, is this was 1992, 1993, they could bring up the entire pit design of the entire pit and be able to rotate it around in real time in 3 dimensions and perform block modeling analysis and triangulation of data points and calculate area and things like that, incredible stuff. I worked on one particular module on that, it was written in C in FORTRAN in roughly 1993 for geotechnical modeling. That software is still in production today. Ported to the PC, it is still out there, what is this now, 2016?

There is probably some code that I wrote that someone is reading right now going 'what was he thinking'? Right. Code can be very long lived. This is a helpful diagram, this is not from DDD, this is from a different book that I will mention a little later, but this is called the purpose alignment model and it is one way of getting your head around the idea of what we mean by Core Domain. Think about all the things that your business does, all the different activities, and grade them according to how mission critical are they, how important are they just to the general running of the business, and how much do they contribute to your business' competitive advantage. How important are they in the marketplace and the reality is that the vast majority of what your company does probably sits here in the bottom right, invoicing customers just all the kinds of stuff that legal, compliance, all the kinds of things your company has to do.

Really, for things in the bottom right you just want parity. You are not trying to innovate or excel, you are not trying to be better than anyone else, you just need to do a good enough job. For things in the bottom left, here, companies should be trying to minimize that stuff or just maintain it, you should not be doing custom software development down here. If you are, you might as well just be burning the money. Over here on the right hand side, we will talk about this in a moment, but you have to be very very careful with custom software development for things in the bottom right.

The question becomes what about things in the top two quadrants, where it really does contribute to your competitive advantage in the market place. The reality is that if something is not only mission critical but it is part of your competitive advantage, if it is a real market differentiator, that is where you want to excel and innovate, where you want to be better than anyone else. In fact, that is where you are probably not really sure if it is going to work or not, you might need to try a few things. You need to do some experiments to find out, and you are blazing a trail. Things that are less mission critical but still potentially differentiating are where you might want to partner with another company. An example of that may be a book publisher like Pearson [inaudible 00:21:49] that publishes the domain driven design book, they might want to branch into a new form of E-publishing or something like that, rather than have that capacity in house they might partner with another company that is a specialist in that so they could accomplish that without having to shift their central focus away from what they do well. That is what we mean by partner.

Now, in domain driven design, Eric spends a lot of time in the book talking about what he calls domain distillation, this is in the fourth part of the book. Domain Distillation. He basically describes domains as three different kinds, three different subtypes. He talks about generic subdomains, supporting subdomains, and core domain. A generic subdomain is anything your business does that other businesses, like yours, do. Where would that land on here? Where do you think? Bottom right, exactly. Generic subdomains, bottom right, and perhaps extending into here.

Then he talks about supporting subdomains. Support Subdomains is things that are specific to your business, so you might have to write some custom software development, do some custom software development. With Supporting Subdomains, what you are really trying to do is write enough software of good quality to be able to support your core domain. Supporting Subdomains probably live somewhere down in there as well but are moving up towards excel and innovate and then Core domain is going to be the smallest thing. This quadrant chart is not to scale. The Core domain is going to be that small thing that involves excelling and innovating and enabling partnerships with other companies so you can get ahead in the marketplace.

I found this tremendously helpful for thinking about this, for example if you are working in a Scrum team and you have a product backlog, what you probably just see, I hope you are not unfortunate enough to have just a sea of user stories. If that is your world, I am sorry. Hopefully, you have some way of thinking about 'What is the relevance importance of these things, and how do they contribute?' If I look at this set of features, are they part of our core domain, do they support our core domain? Or, are they part of a generic subdomain? If they are part of a generic subdomain, don't write custom software if you can avoid it. Just use an open source framework or some off the shelf software, it will be faster and cheaper.

If it is a supporting subdomain, that is an excellent candidate for outsourcing it to contractors. Focus your best designers, focus your best people, do your domain modeling in this area of complexity and uncertainty up in the top, your core domain. When it comes to things, just practical things like a scrum team that is doing sprint planning, getting ready for a sprint and they are estimating stories. Your approach to estimation should be completely different depending on where that story sits, that feature sits in terms of your subdomains. If it is generic, just needs to be good enough, in fact could we use something open source or off the shelf to enable this capability? If it is supporting, then 'well could we get one of the junior staff or contractors to work on that.' We want good quality, we want it well tested, but we are not trying to reinvent the wheel or do something any better than anyone else. If it is core domain, and you are estimating stories, then you should be saying there is a lot of uncertainty around this, there is a lot of risk .. let us give ourselves more time to do this, and maybe we need to do a little exploratory work to figure that out.

Technical considerations or business capabilities. I am firmly a believer in business capabilities, right. I do not care what kind of car or motorbike the delivery driver drives so long as he gets me that pizza in the time frame that I would like and that it tastes good and my children are happy. Part of being able to deliver business capabilities is to understand what kind of playing field you are playing in. That purpose alignment model came out of this book, 'Stand Back and Deliver', a great read. Here is another quadrant chart from that book. In terms of thinking about your project playing field. What kind of project are you working on right now? Is it a project with a lot of complexity or not much complexity in terms of technological complexity or domain complexity? Where does it sit on that spectrum? What about uncertainty in terms of how well understood is what you are building? Is there a lot of uncertainty in terms of what the feature needs to look like?

If it is low uncertainty, low complexity, in the book they call this kind of project a dog project. Laissez-faire. It takes a lot less skill to be able to pull off a project in this area, nicely suited for outsourcing, for contracting, this is probably generic or supporting subdomain. When you have a lot of uncertainty but low complexity, and I think that is where a lot of scrum projects sit well, is what they call a colt. You want a small team, you want agility, a nice cohesive team, and you want to be able to move through that project fairly quickly and get it done. You do not want to be too fancy, in terms of technical complexity. Really, domain driven design for these kinds of colt projects and dog projects, overkill. You are not doing the type of model exploration and discovery I have been talking about. These types of projects are really good for using simpler frameworks like active record and things like that. There is a lot of uncertainty about how the software needs to work, in terms of the features, but not about the technical side or not a lot of complexity in the domain.

You also have projects that have a lot of complexity but not much uncertainty. They call those a cow projects, as it is kind of a plodding idea. They need well defined interfaces, good project management, they need a lot of domain expertise but there is not a whole lot of risk on these kinds of projects other than the risk of introducing additional complexity by going overboard with frameworks and technologies. Then you have got this fourth category of project space. Maybe this is where you find yourself. Now you are on a bull project.

High uncertainty, high degree of complexity in terms of domain. These ones need good management, good leadership, good technical leadership. Domain driven design can work very well down here in the bottom right, if you have got a lot of domain complexity. It works particularly well in the top right here where you have got a lot of domain complexity, where you have got a lot of uncertainty, you are trying to discover what it is that the project needs to do and you are trying to get all of that under control.

I find this kind of way of compartmentalizing things very helpful, because it gives me a language of kind of thinking about it and talking to the business of 'This is the kind of project that you are asking us to do, so this is the environment and the playing field that we find ourselves in, so how are we going to handle that, what would be the appropriate approach.'

Second part of design agility is thinking about modeling and design and thinking about boundaries. Identifying and creating and enforcing software boundaries. Particularly where you have a lot of domain complexity. I do not have time to ... we just spent two days with a great group of people going through and explaining how to do context mapping, there are some great articles out there on how to do context mapping, but basically Eric talked about the importance of having a model with a good boundary around it and understanding what that is. Here is an example of a context map where what we have up here is an AS400 system for managing claims. It is a legacy system, it is very very hard to make changes in there, it is almost impossible to do sophisticated design work and so what Domain driven design says to do, in a context map, draw a circle around it and label it as a big ball of mud and do not try to do sophisticated design work.

It is going to be difficult if not impossible to pull off. What you would need to do is to create a new context, in this case called warranty administration, that duplicates over time the critical core domain aspects of this legacy system then build what is marked here as an ACL, an anti-corruption layer. Basically an API that lets you wall yourself off from that big ball of mud, as they have the tendency to sprawl and be able to do the design work that you need to do. This is all about saying we have got this new context, we want to do some really supple design work here and so we need to figure out what that model looks like, what its boundary is and how we are going to interact with this upstream monolith that is going to overwhelm our design work if we let it. It is a little bit like this idea ...

This is in the US. There are certain rivers in the United States that flood periodically. This person wanted to do some fairly sophisticated design work, they wanted to have a nice house, some land, so they built an anti corruption layer against the sprawling monolith ... I am stretching the metaphor, but you get the idea. What we are talking about there is when you are working with these types of legacy systems, and you can read Martin Fowler's article on the strangler pattern if this is new to you and that will help you understand some of this, and Eric, on DDDcommunity.org, Eric has a great series of videos talking about these different patterns of doing this when you have legacy systems.

The idea is if you are trying to integrate with one of these big balls of mud, you need to put the work in to isolate yourself from that thing. I worked with an agile team a few years ago, came in, they brought me in, did a days training, we were doing a workshop for a few days and what they were trying to do was take this server based system and move it to the cloud so people could access it. I asked them 'Well, have you budgeted any time to build the API to the backend?' And it was like 'We will deal with that when we get to it.' I was 'Well, why aren't you thinking about that now, isn't that a critical piece? Doesn't the front end drive the backend and can you use the front end without the backend?' 'Oh, no, no it is all going to be fully integrated.' 'Well, when are you doing the integration?' ' Oh, right at the end'. Well, what is problematic about that?

They are giving the appearance throughout the project that they are delivering things, but they have not delivered anything because nothing actually works. What ended up happening on that project, and I said 'you need to budget some time now to at least have an idea of what that API looks like, and to be able to maybe stub out that API and have a nice test suite around that API and be able to start integrating with that as early as you possibly can.' They did not listen, the project was months late, there was a lot of finger pointing and that is what happens when you do not listen.

Boundaries are fragile. Somebody might say 'Well, we have got this one piece of data that we need to get from this legacy system, so let us just go around the API for this one thing. A little bit of water starts to leak into the house, it might not be so clear from the house. The next developer comes along and says 'Well, I need to just get this one other thing' and pretty soon you do not have an anti-corruption layer anymore. You have to invest effort in doing these boundaries, this is design work. It may seem not very exciting design work, but this is design work. You want to avoid this kind of situation. Who wants to live in that house? You might feel like that is your code base right now. 'I am trying to build this house! It keeps flooding!' I wonder why. Boundaries take work. They take effort.

Technical leadership, let us talk about technical leadership. What is leadership? I think leadership is not about authority. A lot of people think 'well, I have been made the architect, I have been made the lead, the dev lead, so I have the authority to tell people what to do'. Well, you are in for a shock. Leadership is about influence, it is about being able to get the respect of other people and have them respect your opinion because it comes from experience and it is a collaborative kind of exercise. Doing this good design work is hard, but a leader which I would hope that many of you aspire to design leadership in your teams if you are not doing that already, and good design work is hard but you then have to socialize that design to the rest of the team to avoid the kind of situation we had where the boundary gets broken because one person does not understand why it is important.

The way I like to define technical leadership is this way: The job of a technical leader, a dev lead or a system architect, whatever that is, is that your team "falls into technical success." You provide a technical environment for the team where they can make the right decisions by default without having to think about them. In domain driven design terms, if you are familiar with that, it is make socializing, what are aggregates, what are these building block patterns, what are these technical things and how do they work, what does that look like in the code so everyone knows why that is important, and like I said it is about influence, not authority.

Many people read the four principals for the Agile manifesto, the four values, but do not actually read the twelve principles on the second page. I am a firm believer in this, that we want technical excellence and we want good design and that actually enhances agility. The most significant complexity of many applications, it is not technical, it is in the ... anyone? Domain itself. The activity or business of the user, that is why it is called domain driven design , not technical driven design or framework driven design, it starts with the business domain because that is where the complexity is. He went on to say ' a successful design has to deal with this business domain complexity' and how he put it as the title of his talk this morning, 'making that the heart of the software.'

How do we do this? This involves understanding the business language. It starts with what domain driven design calls ubiquitous language. Learning to speak the language of the business domain and investing the time to do that. I gave this example in the workshop, I have changed the names, for this, but this is a real email exchange on a project I was involved with during 2006 where Pam the accountant sent an email to John the AS400 developer asking about this very simple idea of retail price, and John came back with a perfectly correct but completely unhelpful answer. Which Pam was very upset about, and so she wrote an email to Claire, the business analyst, expressing how upset she was about that, but even then she was trying to find some common ground with John the developer and Claire tried to help out. Does this seem like Ubiquitous language? It is the antithesis of that. It really is. Everyone understands ... it had the real swear in there, I edited that, but you understand and that is the important thing. You can interpret that in any language you want, and it is universal.

What we are talking here about, is talking a common ubiquitous language. Ubiquitous is just a fancy word for common, or a lingua franqua, a common shared language between the business and the technical team. It is not just the technical people going to the business people saying 'tell us all your terminology and we will write it down and put it in the code', right, does that sound like collaboration? Not so much. It is working together to flesh this out. In this case here, I have given some examples of something we used in the workshop, the idea of limited liability on an insurance contract. I have got the legal definition, I have got a cartoon that was drawn by someone in the business that explains how limited liability works as a shield, and the liabilities are unable to get through, we have got people on the team talking about limited liability and we have got the actual method called limited liability that goes through and aggregates the claim amount for the total claim amount, compares that to the purchase price, slash twenty percent.

Ubiquitous language. It is in the code, it is in the conversation, it is on the wiki, everyone understands what it means. Related to this is the idea of a reference scenario, what do we mean by a reference scenario? Domain driven design does not start with an abstract model. It starts with a concrete business problem, a specific concrete business problem. Like Eric said, it is not about realism, it is about usefulness. Walking through a specific business problem, I think that those that come to the workshop over the past few days were surprised about how specific I mean by specific, right? Yeah.

We are probably familiar with a lot of these books, TDD talks about three steps in writing any piece of production code, write a failing test, make it pass, have a coffee, write a failing test, make it pass, have a coffee. That is the TDD cycle. If you do it that way, you are actually missing the design step. Refactoring is formally defined as improving the design of the system without changing the behavior, so it is micro design. Refactoring, if you are doing it as a continuous process, is microdesign. You are making very small steps along the way. You are making it part of what you are doing, what domain driven design emphasizes is not so much micro design but the concepts. If you can introduce a new concept like limited liability that was not in the code before, that is not an emergent concept from the code, that is a concept that you have modeled from the business and I believe it is one hundred times more powerful than an emergent concept in the code because it can transform the whole nature of the code in ways you would not expect, which is part of why I find DDD so fun.

44 mins in...

The fourth thing, four of four, is baking design into your process. I want you to think about this, Scrum ... who is following Scrum, most people? What else are people doing? Kanban, XP, there is always one person doing XP. One faithful ... no, all the practices? Nice. Rachel Davies gave a nice talk last year, I think it was at on taking extreme program to the next level? That is worth watching but that is not part of this talk. Scrum does not really say all that much about how to do the work, and yet people tend to think, when you say 'Well, what process do you follow?' 'Well, we follow Scrum, we are doing Scrum.' You are not actually doing Scrum. Scrum is just a description of how you are arranging your activities as a team. Scrum does not say anything about how to actually do the work. It is just a way of organizing a team with a few ceremonies and artifacts to say 'here is how you can structure things in such a way so you can actually accomplish some work on a regular basis.' And hopefully it is potentially shippable at the end of the spring.

I really believe that agile is not the work, design is the work. Development is the work, that is what we are actually doing, it is a key key part of what we do, it is an integral part of what we do. Most teams that I go into, I walk into their area and I will se on the wall maybe a task board, some metrics and maybe a burn down chart, and I will say 'what kind of domain are you working in?''Really complex, complex business domain, lots of problems to solve.' I look around like, 'where are your sketches of the model? Where do you talk about design?''Oh, we do not have time for that.''Well, you seem to have time to put all those other charts up.' I am getting a little cynical, moving on.

That was the one rant. When you have that intersection of market differentiating and mission critical and you have a lot of domain complexity, that is when you are in the realm of core domain and that is the sweet spot for DDD. I am not saying that aspects of DDD, like ubiquitous language and collaborative modeling and just using things like aggregates and building blocks are not applicable when you do not have those three things, but bringing all of DDD together really works well there. If you do not take that into account, if you do not deal with that domain complexity, what tends to happen over time with any system is, yes, you can incrementally deliver value, but soon you reach the point where your design can no longer support the types of features that you need to deliver and your ability to deliver value over time diminishes.

Then people start calling for a rewrite, cannot work with this system anymore, it is too slow for everyone to get stuff done. That central place really is the sweet spot for domain driven design, I am not going to talk much about this, Eric wrote a paper, you can google or you can look on domainlanguage.com/ddd/whirlpool, but the basic idea is he gave a talk about five years ago on folding Agile and design and the idea that when you are doing domain driven design, there is this kind of cyclical iterative process, of you can start anywhere but you have got a concrete business scenario, for example, and you create a model, a mental model, of how might we address that, what are the concepts, and then you run another scenario past it and see that it breaks my model and I need to tweak my model, and you are going through this iterative kind of process of refining your model, breaking your model, fixing it, transforming it.

At some point, writing a bit of code, maybe some tests, making some assertions, coding up some classes, objects, to add some rigor to that model and see what else breaks and what you need to tweak. What I find is when I work with teams that integrate that kind of approach of iterative design into their process, what tends to happen over time is that they reach a point where they say 'Well, I need to do a little bit more modeling' and they run through the whirlpool again and they introduce a new concept like limited liability, and the value goes up. Then they reach another point where they are like 'This concept is not in the code, we do not know how to do this.' They run through the whirlpool again and over time they keep doing this.

Then they reach a point, maybe, and this happened on a project several years ago that I remember vividly, it was right near the end of the project and it was right about to go through stress testing and into production and they realized that one of the fundamental concepts on the way that they have designed it just did not work. They had been applying DDD throughout the course of the project, so over the course of a day I sat down with the dev lead, and we peer programmed out, we white boarded out some options and talked it over with the domain expert and came up with something, and it was like 'wow, this could really make a difference. I think we have really captured what the business was trying to do here' so we pulled a few domain experts in and they said 'aren't we doing that already? That is obvious' and we were like 'No? Duh."

That day we did a code probe of lieke, 'let's see what this looked like' and it worked. The following Monday he finished that off and productionized it and it really was the kind of situation where we saw a huge breakthrough in how the software works, it was very late in the project. I see this kind of pattern with domain teams that are doing domain driven design, when you are using ubiquitous language and supple design, you are able to do this kind of thing. Not always, but when you have this kind of assumption breaking moment that transforms your model, you can really have a breakthrough happen and be able to deliver a lot more value and then it may just taper off again.

[50 mins]

The idea is, we are going for a dramatic increase in domain knowledge. Here in a project, you have the least amount of domain knowledge. Dan North talks about deliberate discovery, and you will probably hear Liz Keogh talk about that too, the process of deliberate discovery, being intentional about discovering things. It is combining that incremental development that Scrum talks about with iterative design, and not just saying design pays off in the long run. I think it does, but I think what continuous attention to design can do is actually accelerate delivery in the mid to short term as well.

I just want to talk about a few things, a few practical things, I like to run design workshops with teams, I believe that designers really need to know your business domain. You need to understand the specifics of what you are trying to solve. It is not just enough to be good at Redis and PHP or Csharp or Java or Elixir or Ruby or whatever the language needs to be. Like Eric said, that kind of technical mastery is knowing the tools and being good with the tools and that is important. DDD says we need to up our game. Move on to actually understanding what the domain is trying to do so we avoid leaky abstractions. I am going to skip ...

I want to talk about a couple of related disciplines to DDD. One is user experience design. So, DDD, if you think about an ice berg, how much do they say of an iceberg you can actually see above the water line? What percent? Ten? Yeah, some people say an eighth, and a bulk of the iceberg is hidden. Did not really help the Titanic either way. They probably should have seen the ten percent ... User experience design is concerned primarily with what? The visible part of the iceberg. The way I think about Domain-Driven Design is it is concerned with everything below the water line, that conceptual model and all the systems that have to interact and the contexts that have to interact to produce that.

I am just going to recommend a couple of books that you read. I wrote on my blog and my summary of Lean User Experience, but if you are interested in how you integrate user experience design into your process, this is the book to read by Geoff and Josh, Lean User Experience. I will put these slides on later, so you have access to those. Another great book that just came out, is the Design Studio Method. There is a lot in this book that is applicable to how you do domain driven design as well, in terms of how you approach design.

Another technique from the Behavior Driven Design folks, particularly Matt Wynne is the idea of Example Mapping. Who does backlog grooming, anyone do backlog grooming? Don't you just want to kill yourself in those backlog grooming meetings? Is it mostly just about estimating stories? Yeah, make it stop. Example Mapping is basically saying we have got this feature to work on, process refunds, let us talk about examples about how we would process refunds. What do we do, for example, when a customer has a receipt and it is within a limit? That would be one example, and let us talk about that. Let us mark that one in green, then what would the rule be for that? Well, the customer has to have a receipt. Then we have this over rule of a fourteen day limit, so let us put the rules in blue. The idea is, in fifteen to twenty minutes, you take a story and try to figure out: What are the examples? How should it work? This is a collaborative thing that the team does with the business people and the product owner.

Then the output from that you then take away and do what you need to do to get that into your software, if you have questions, they go on a red or pink card. What if proof of purchase is a bank statement? If you do an example mapping session and you get to the end and you find you have mostly pink stickies or mostly red cards? You are not ready to work on that thing yet because you do not have enough knowledge. I just want to end with a couple of ideas.

A lot of people, like you said, you are feeling like you are serving the process. What can happen is that the process can smother good design work, now Fred Brooks, like I mentioned before, who wrote the Mythical Man Month, this is out of a more recent book called 'The Design of Design'. It is a book about recursion, no, it is not really. No one laughed, tough crowd. He basically says you have to hold off design, or hold off process, and by that he means the formal aspects of it long enough so that you can do that design work. The sentiment there is that process can get in the way, sometimes, of figuring out not only design as a discovery activity as well as design as in how do we actually implement this.

I will let you read this one, this is a little cartoon I did last year. What happened was I worked with a team, they just came off a two week project inception, and most of that project inception was basically like a two week backlog grooming meeting, where they were just estimating stories. The conversation went a little bit like this. There is this notion that the design will just emerge, but apparently you need to invest a huge amount of effort in figuring out what the requirements are.

I just want to close with this. The opportunity we have as software designers is to learn to handle the complexity. In a complex domain and not to shy away from it. Our job, and I want to leave you with this as kind of an inspiring quote, is that our job is to try and take these complicated things in the business domain and through modeling make them simple, and express that in the code.


